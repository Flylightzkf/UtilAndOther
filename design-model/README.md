# 项目介绍
|- model:

|-- m01_simple_factory: 简单工厂模式
将要生产的产品定义为抽象类，具备特性，输入参数，定义一个工厂类，根据不同的参数来生成不同的实现类返回，从而实现不同的功能    

|-- m02_strategy: 策略模式
    定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化不会影响到使用算法的客户
    
|-- m03_decorator: 装饰器模式
    动态地给对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类实现更为灵活。
    与策略模式的区别是，当需要多种策略组合使用时，就可以利用装饰器模式来进行组合，而策略模式只能选择一种策略
    
｜-- m04_proxy: 代理模式
    想要给之前的方法前后添加一些额外的处理。静态代理、动态代理：jdk动态代理和CGLIB动态代理
    代理模式的应用场景：
    1. 远程代理，为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。
    2. 虚拟代理，根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。
    3. 安全代理，用来控制真实对象访问时的权限。一般用于对象应该有不同的访问权限的时候。
    4. 智能指引，当调用真实的对象时，代理处理另外一些事。
    
|-- m05_factory_method: 工厂方法模式
    定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
    工厂方法模式的应用场景：
    1. 创建对象需要大量重复的代码。
    2. 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节。
    3. 一个类通过其子类来指定创建哪个对象。

|-- m06_prototype: 原型模式
    克隆，复杂对象的创建比较麻烦，但是复制比较简单，就可以利用原型模式来进行复制，从而达到创建复杂对象的目的。
    
|-- m07_template_method： 模版方法模式
    定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模版方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
    模版方法模式的应用场景：
    1. 多个子类有公有的方法，并且逻辑基本相同时。
    2. 重要、复杂的算法，可以把核心算法设计为模版方法，周边的相关细节功能则由各个子类实现。
    3. 重构时，模版方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。

|-- m08_facade: 外观模式
    为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
    外观模式的应用场景：
    1. 为一个复杂子系统提供一个简单接口。
    2. 提高子系统的独立性。
    3. 在层次化结构中，可以使用外观模式定义系统中每一层的入口。

|-- m09_builder：建造者模式
    将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
    建造者模式的应用场景：
    1. 相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。
    2. 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以采用该模式。
    3. 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。
    4. 在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时，也可以采用建造者模式封装该对象的创建过程。

|-- m10_observer: 观察者模式
    定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
    观察者模式的应用场景：
    1. 关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。
    2. 事件多级触发场景。
    3. 跨系统的消息交换场景，如消息队列的处理机制。
